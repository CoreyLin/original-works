# 成员资格服务提供者(MSP)

该文档提供了关于MSPs的设置和最佳实践的详细信息。

成员服务提供者(MSP)是一个旨在提供成员操作架构抽象的组件。

特别是，MSP抽象出了颁发和验证证书以及用户标识验证背后的所有加密机制和协议。MSP可以定义自己的标识概念，以及监管（标识验证）这些标识和验证这些标识(签名生成和验证)的规则。

一个Hyperledger Fabric区块链网络可以由一个或多个msp控制。这提供了成员操作的模块化，以及不同成员标准和架构之间的互操作性。

在本文档的其余部分中，我们将详细介绍由Hyperledger Fabric支持的MSP实现的设置，并讨论有关其使用的最佳实践。

## MSP配置

要设置一个MSP的实例，需要在每个peer和orderer上本地指定其配置(启用peer签名和orderer签名)。除此之外，需要在通道上为所有通道成员指定MSP配置，从而为所有通道成员启用peer、orderer、客户端标识验证和各自的签名验证(标识验证)。

首先，需要为每个MSP指定一个名称，以便在网络中引用该MSP(例如**msp1**、**org2**和**org3.divA**)。这是在通道中被引用代表联盟、组织或组织部门的MSP成员规则的名称。这也称为MSP标识符或MSP ID。每个MSP实例都要求MSP标识符是惟一的。例如，如果在系统通道创世区块检测到两个具有相同标识符的MSP实例，则orderer设置将失败。

在默认实现MSP的情况下，需要指定一组参数，以允许标识(证书)验证和签名验证。这些参数由RFC5280推导得到，包括:

* 自签名(X.509)证书的列表，以构成信任的根

* 一个X.509证书列表，用于表示此提供者考虑用于证书验证的中间CA;这些证书应该由信任根证书中的一个证书进行认证;中间CA是可选参数

* 一个具有一个可验证证书路径的X.509证书的列表，该证书恰好指向表示此MSP管理员的信任根证书中的一个证书;这些证书的所有者有权请求更改此MSP配置(例如根CAs、中间CAs)

* 此MSP的合法成员应在其X.509证书中包含的一个组织单元列表;这是一个可选的配置参数，用于多个组织利用相同的信任根和中间CA，并为其成员保留一个OU字段

* 一个证书撤销列表(CRL)的列表，每个证书撤销列表恰好对应于列出的(中间或根)MSP证书颁发机构中的一个;这是一个可选参数

* 一个自签名(X.509)证书列表，构成TLS证书信任的TLS根。

* 表示此提供者考虑的中间TLS CAs的一个X.509证书列表;这些证书应该由TLS信任根证书中的一个证书进行认证;中间CAs是可选参数。

这个MSP实例的有效标识需要满足以下条件:

* 它们的形式为X.509证书，具有可验证的证书路径，该证书恰好指向信任证书的根证书之一;

* 他们不包括在任何CRL中;

* 它们在其X.509证书结构的OU字段中列出了MSP配置的一个或多个组织单元。


有关当前MSP实现中标识有效性的更多信息，请参考MSP Identity Validity Rules。

除了和验证的相关参数外，对于enable节点的MSP，在节点上，MSP被实例化以进行签名或标识验证，还需要指定：

* 被节点用于签名的签名密钥(目前只支持ECDSA密钥)
* 节点的X.509证书，这是在此MSP的验证参数下的有效标识。

值得注意的是，MSP标识永远不会过期;只能通过将它们添加到适当的CRL来撤销它们。此外，目前不支持强制撤销TLS证书。

## 如何生成MSP证书及其签名密钥?

要生成X.509证书来提供其MSP配置，应用程序可以使用Openssl。我们强调，在Hyperledger Fabric中不支持包括RSA密钥在内的证书。

也可以使用**cryptogen**工具，其操作将在Getting Started中进行说明。

还可以使用Hyperledger Fabric CA生成配置一个MSP所需的密钥和证书。

## MSP在peer和orderer端的设置

要设置一个本地MSP(无论对一个peer还是对一个orderer)，管理员应该创建一个包含六个子文件夹和一个文件的文件夹(例如**$MY_PATH/mspconfig**):

1. 一个文件夹**admincerts**：包含PEM文件，每个PEM文件与一个管理员证书对应

2. 一个文件夹**cacerts**：包含PEM文件，每个PEM文件与根CA证书对应

3. （可选）一个文件夹**intermediatecert**：包含PEM文件，每个PEM文件对应于一个中间CA的证书

4. （可选）一个**config.yaml**：配置支持的组织单元和标识分类(参见下面的各个部分)。

5. （可选）一个文件夹**crls**：用于包含考虑的CRLs

6. 一个**keystore**文件夹：用于包含具有节点（peer或orderer）签名密钥的PEM文件;我们强调，目前不支持RSA密钥

7. 一个**signcerts**文件夹：包含一个带有节点（peer或orderer）的X.509证书的PEM文件

8. (可选)一个**tlscacerts**文件夹：其中包含PEM文件，每个PEM文件对应于一个TLS根CA证书

9. (可选)一个**tlsintermediatecerts**文件夹：其中包含PEM文件，每个PEM文件与一个中间TLS CA证书对应

在节点的配置文件中（core.yaml用于peer，orderer.yaml用于orderer），需要指定两个东西：1.到mspconfig文件夹的路径 2.节点的MSP的MSP标识符。mspconfig文件夹的路径应该是相对于FABRIC_CFG_PATH的相对路径，并作为peer的参数**mspConfigPath**和orderer的参数**LocalMSPDir**的值提供。节点的MSP标识符作为参数**localMspId**的值提供给peer，作为参数**LocalMSPID**的值提供给orderer。可以使用peer的CORE前缀的环境变量（比如CORE_PEER_LOCALMSPID）和使用orderer的ORDERER前缀的环境变量（比如ORDERER_GENERAL_LOCALMSPID）来覆盖这些变量。注意，对于orderer设置，需要生成并向orderer提供系统通道的genesis区块。下一节将详细介绍此genesis区块的MSP配置需求。

“本地”MSP的重新配置只能手动进行，并且需要重新启动peer或orderer进程。在后续版本中，我们的目标是提供在线/动态重新配置(即不需要使用一个节点管理的系统链码来停止节点)。

## 组织单元

为了配置组织单元列表，并且组织单元列表主要包含在这个MSP的有效成员的X.509证书中，**config.yaml**文件需要指定组织单元标识符。举个例子:

    OrganizationalUnitIdentifiers:
      - Certificate: "cacerts/cacert1.pem"
        OrganizationalUnitIdentifier: "commercial"
      - Certificate: "cacerts/cacert2.pem"
        OrganizationalUnitIdentifier: "administrators"
	
上面的例子声明了两个组织单元标识符:**commercial**和**administrators**。如果一个MSP标识携带至少其中一个组织单元标识符，则它是有效的。**Certificate**字段指向CA或中间CA证书路径，在此路径下，应该验证具有特定OU的标识，也就是说应该用此CA路径验证具有特定OU的标识。该路径是相对于MSP根文件夹的相对路径，不能为空。

## 标识分类

默认的MSP实现允许根据x509证书的OU将标识进一步划分为客户端和peer。如果一个标识提交交易（submits transactions）、查询peer等，则应该将这个标识分类为**客户端**。如果一个标识背书或提交（commit）交易，则应该将这个标识分类为**peer**。为了定义一个给定MSP的客户端和peer，需要适当地设置config.yaml文件。举个例子:

    NodeOUs:
      Enable: true
      ClientOUIdentifier:
        Certificate: "cacerts/cacert.pem"
        OrganizationalUnitIdentifier: "client"
      PeerOUIdentifier:
        Certificate: "cacerts/cacert.pem"
        OrganizationalUnitIdentifier: "peer"

如上所示，**NodeOUs.Enable**设置为**true**，这将启用标识分类。然后，通过为**NodeOUs.ClientOUIdentifier**键和**NodeOUs.PeerOUIdentifier**键设置以下属性来定义客户端和peer标识符。

a. **OrganizationalUnitIdentifier**:将其设置为与客户端(peer)的x509证书应该包含的OU匹配的值。

b. **Certificate**:将此设置为CA或中间CA，在该CA下应该验证客户端(peer)身份。该字段是相对于MSP根文件夹的相对路径。它可以是空的，这意味着可以在这个MSP配置中定义的任何CA下验证这个标识的x509证书。

启用标识分类后，MSP管理员需要是该MSP的客户端，这意味着MSP管理员的x509证书需要携带标识客户端的OU。还要注意，一个标识要么是一个客户端，要么是一个peer。这两种分类是相互排斥的。如果一个标识既不是客户端也不是peer，则验证将失败。

最后，请注意，对于升级后的环境，在使用标识分类之前，需要启用1.1通道功能。

## 通道MSP设置

在系统生成时（At the genesis of the system），需要指定在网络中出现的所有MSPs的验证参数，并将其包含在系统通道的创世区块中。回想一下，MSP验证参数包括MSP标识符、信任证书的根、中间CA和管理员证书，以及OU规范和CRL。系统创世区块在orderers的设置阶段提供给orderers，并允许orderers对通道创建请求进行验证。如果系统创世区块包含两个具有相同标识符的MSP，则orderer将拒绝这个系统创世区块，从而导致网络引导失败。

对于应用程序通道，只有控制（监管）通道的MSPs的验证组件需要驻留在通道的genesis区块中。我们强调，对于应用程序来说，在指导一个或多个创世区块的peer加入通道之前，**应用程序有责任**确保通道的genesis块(或最新的配置区块)中包含正确的MSP配置信息。

在使用configtxgen工具引导一个通道时，可以通过在mspconfig文件夹中包含MSP的验证参数，并在**configtx.yaml**的相关部分中设置该路径，从而配置通道MSPs。

通道上的一个MSP的重新配置，包括与该MSP的CAs关联的证书撤销列表的声明，是通过由MSP的一个管理员证书的所有者创建一个**config_update**对象来实现的。然后，由这个管理员管理的客户端应用程序将向出现此MSP的通道宣布此更新。

## 最佳实践

在本节中，我们将详细介绍在常见场景中进行MSP配置的最佳实践。

### 1) 组织/公司与MSPs之间的映射

我们建议在组织和MSP之间建立一对一的映射。如果选择了不同类型的映射，则需要考虑以下因素:

* 一个使用多个MSPs的组织。这与一个包含多个部门的组织的情况相对应，该组织包括多个部门，每个部门都由其MSP代表，或者是出于管理独立性的原因，或者是出于隐私的原因。在这种情况下，一个peer只能由一个MSP拥有，并且不能将具有其他MSP身份的peer视为同一组织的peer。这意味着，peer可以通过gossip组织范围内的数据与一组属于相同子部门的peer共享，而不是与构成实际组织的完整提供者共享。

* 多个组织使用一个MSP。这与由相似成员架构治理的组织联盟的情况相对应。这里需要知道，peers会将组织范围内的消息传播给在相同MSP下具有标识的peer，而不管它们是否属于相同的实际组织。这是MSP定义和/或peer配置粒度的限制。

### 2) 一个组织有不同的部门(例如组织单元)，它希望授予这些部门访问不同通道的权限。

有两种处理方法:

* 定义一个MSP来容纳这个组织所有成员的成员资格。该MSP的配置将包括根证书、中间证书和管理员证书的列表;成员身份标识包含这个成员所属的组织单元(OU)。然后可以定义策略来捕获一个特定OU的成员，这些策略可以构成通道的读/写策略或链码的背书策略。这种方法的一个限制是，gossip peers会将本地MSP下具有成员身份标识的peer视为同一组织的成员，并因此与他们gossip组织范围内的数据(例如，他们的状态)。

* 为每个部门定义一个MSP。这将涉及为每个部门指定一组根CAs、中间CAs和管理员证书，以便在MSPs之间不存在重叠的证书路径。这将意味着，例如，每个部门使用一个不同的中间CA。这里的缺点是管理多个MSPs而不是一个，但是这可以避免前面方法中出现的问题。还可以通过利用MSP配置的OU扩展为每个部门定义一个MSP。

### 3) 将客户端与同一组织的peers中分离出来。

在许多情况下，需要从一个标识本身检索标识的“类型”(例如，可能需要保证背书是由peers派生的，而不是由客户端或仅作为orderer的节点派生)。

对这些需求的支持有限。

允许这种分离的一种方法是为每个节点类型创建一个单独的中间CA——一个用于客户端，一个用于peers/orderers;并配置两个不同的MSPs——一个用于客户端，另一个用于peers/orderers。这个组织应该访问的通道将需要包括两个MSP，而背书策略将仅利用指向peers的MSP。这将最终导致将组织映射到两个MSP实例，并对peers和客户端交互的方式产生一定的影响。

Gossip不会受到很大的影响，因为同一组织的所有peers仍然属于一个MSP。peers可以将某些系统链码的执行限制为基于本地MSP的策略。例如，peers只会在peers的本地MSP的管理员签署请求时执行“joinChannel”请求，该管理员只能是一个客户端(终端用户应该位于该请求的初始位置)。如果我们接受能够成为一个peer/order MSP的成员的客户端只能是这个MSP的管理员，那么我们就可以绕过这种不一致。

这种方法要考虑的另一点是，peers根据请求发起者在请求发起者本地MSP中的成员身份授权事件注册请求。显然，由于请求的发起者是一个客户端，这个请求发起者总是被认为属于与被请求的peer不同的MSP，而这个peer将拒绝请求。

### 4) 管理员证书和CA证书

将一个MSP的管理员证书设置为与该MSP考虑的用于**信任根证书**或中间CA的任何证书不同，这一点很重要，也就是说管理员证书需要是一个单独的证书。这是一种常见的(安全)实践，将成员资格组件的管理职责与颁发新证书和/或验证现有证书分开。

### 5) 将一个中间CA列入黑名单

如前所述，一个MSP的重新配置是通过重新配置机制(为这个本地MSP实例手动重新配置，并通过为一个通道的MSP实例正确构造**config_update**消息)实现的。显然，有两种方法可以确保一个MSP中考虑的中间CA不再被考虑用于MSP的身份验证:

1. 重新配置MSP，使其不再在可信的中间CA证书列表中包含该中间CA的证书。对于本地配置的MSP，这意味着此CA的证书将从intermediatecerts文件夹中删除。

2. 重新配置MSP，使其包含一个CRL，该CRL由信任根生成，声明废除前述提到的中间CA的证书。

在当前的MSP实现中，我们只支持方法a，因为它更简单，并且不需要将不再被考虑的中间CA列入黑名单。

### 6) CAs和TLS CAs

MSP标识的根CAs和MSP TLS证书的根CAs(以及相关的中间CAs)需要在不同的文件夹中声明。这是为了避免不同类型证书之间的混淆。对于MSP身份和TLS证书，并不禁止重用相同的CAs，但是最佳实践建议在生产中避免这种情况。
